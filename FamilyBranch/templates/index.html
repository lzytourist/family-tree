{% extends 'base.html' %}

{% block style %}
    <style>
        .node circle {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 1px;
        }
    </style>
{% endblock %}

{% block content %}
    <div class="ui modal" id="personModal">
        <i class="close icon"></i>
        <div class="header">
            Modal Header
        </div>
        <div class="content">
            <p>Person information</p>
            <div id="info"></div>
        </div>
    </div>

    <div id="svg" style="padding: 10px"></div>

    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
            integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        const svgContainer = document.getElementById('svg');
        $('.ui.modal').modal();

        const chart = () => {
            const width = window.innerWidth - 20;
            const marginTop = 10;
            const marginRight = 10;
            const marginBottom = 10;
            const marginLeft = 40;

            // Rows are separated by dx pixels, columns by dy pixels. These names can be counter-intuitive
            // (dx is a height, and dy a width). This because the tree must be viewed with the root at the
            // “bottom”, in the data domain. The width of a column is based on the tree’s height.
            let root;
            const dx = 25;
            const dy = 180;

            const fetchData = async (parent_id) => {
                try {
                    const res = await fetch(`/api/people/${parent_id}/relation`);

                    if (res.ok) {
                        return await res.json();
                    }
                } catch (err) {
                    console.log('Error', err)
                }
                return null;
            };

            const init = async () => {
                const flare = await fetchData({{ parent_id }});
                if (flare === null) {
                    alert('No data found');
                    return;
                }

                root = d3.hierarchy(flare, d => d.children);

                root.x0 = dy / 2;
                root.y0 = 0;
                root.descendants().forEach((d) => {
                    d.id = d.data.id;
                    d._children = d.children;
                });

                update(null, root);
            };

            init();

            const collapse = (d) => {
                if (d.children) {
                    d._children = d.children;
                    d._children.forEach(collapse);
                    d.children = null;
                }
            };

            const toggleChildren = async (event, parent) => {
                if (parent.children) {
                    parent._children = parent.children;
                    parent._children.forEach(collapse);
                    parent.children = null;
                } else if (parent._children) {
                    parent.children = parent._children;
                } else {
                    // Fetch person's relations
                    const res = await fetchData(parent.data.id);
                    if (res !== null && res.children.length) {
                        const childNodes = res.children.map(child => {
                            const node = d3.hierarchy(child);
                            node.parent = parent;
                            node.depth = parent.depth + 1;
                            node.height = parent.height - 1;
                            node.id = node.data.id;
                            return node;
                        });
                        console.log(childNodes);
                        parent.children = childNodes;
                    }
                }

                update(event, parent);
            };

            // Define the tree layout and the shape for links.
            const tree = d3.tree().nodeSize([dx, dy]);
            const diagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x);

            // Create the SVG container, a layer for the links and a layer for the nodes.
            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", dx)
                .attr("viewBox", [-marginLeft, -marginTop, width, dx])
                .attr("style", "max-width: 100%; height: auto; font: 14px sans-serif; user-select: none;");

            const gLink = svg.append("g")
                .attr("fill", "none")
                .attr("stroke", "#0056d2")
                .attr("stroke-opacity", 0.6)
                .attr("stroke-width", 1.8);

            const gNode = svg.append("g")
                .attr("cursor", "pointer")
                .attr("pointer-events", "all");
            
            const getPersonInformation = async (person) => {
                const response = await fetch(`/api/people/${person.data.id}`);

                if (response.ok) {
                    console.log(await response.json());

                    $('#personModal').modal('show');
                }
            };

            const update = (event, source) => {
                const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition

                const nodes = root.descendants().reverse();
                const links = root.links();

                tree(root);

                let leftW = root;
                let rightW = root;
                let topH = root;
                let bottomH = root;
                root.eachBefore(node => {
                    if (node.x < leftW.x) leftW = node;
                    if (node.x > rightW.x) rightW = node;

                    if (node.y < topH.y) topH = node;
                    if (node.y > bottomH.y) bottomH = node;
                });

                const height = rightW.x - leftW.x + marginTop + marginBottom;
                let newWidth = bottomH.y - topH.y + marginLeft + marginRight;

                if (width < newWidth) newWidth -= width;
                else newWidth = 0;

                const transition = svg.transition()
                    .duration(duration)
                    .attr("height", height)
                    .attr("viewBox", [-marginLeft, leftW.x - marginTop, width + newWidth, height])
                    .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"));

                // Update the nodes…
                const node = gNode.selectAll("g")
                    .data(nodes, d => d.id);

                // Enter any new nodes at the parent's previous position.
                const nodeEnter = node.enter().append("g")
                    .attr("transform", d => `translate(${source.y0},${source.x0})`)
                    .attr("fill-opacity", 0)
                    .attr("stroke-opacity", 0)
                    .on("click", (event, d) => {
                        if (event?.ctrlKey) {
                            getPersonInformation(d);
                        } else {
                            toggleChildren(event, d);
                        }
                    });

                nodeEnter.append("circle")
                    .attr("r", 3.5)
                    .attr("fill", d => d._children ? "#6435c9" : "#3d01c9")
                    .attr("stroke-width", 20);

                nodeEnter.append("text")
                    .attr("dy", "0.31em")
                    .attr("x", 6)
                    .attr("text-anchor", 'start')
                    .text(d => d.data.name)
                    .clone(true).lower()
                    .attr("stroke-linejoin", "round")
                    .attr("stroke-width", 4)
                    .attr("stroke", "white");

                // Transition nodes to their new position.
                const nodeUpdate = node.merge(nodeEnter).transition(transition)
                    .attr("transform", d => `translate(${d.y},${d.x})`)
                    .attr("fill-opacity", 1)
                    .attr("stroke-opacity", 1);

                // Transition exiting nodes to the parent's new position.
                const nodeExit = node.exit().transition(transition).remove()
                    .attr("transform", d => `translate(${source.y},${source.x})`)
                    .attr("fill-opacity", 0)
                    .attr("stroke-opacity", 0);

                // Update the links…
                const link = gLink.selectAll("path")
                    .data(links, d => d.target.id);

                // Enter any new links at the parent's previous position.
                const linkEnter = link.enter().append("path")
                    .attr("d", d => {
                        const o = {x: source.x0, y: source.y0};
                        return diagonal({source: o, target: o});
                    });

                // Transition links to their new position.
                link.merge(linkEnter).transition(transition)
                    .attr("d", diagonal);

                // Transition exiting nodes to the parent's new position.
                link.exit().transition(transition).remove()
                    .attr("d", d => {
                        const o = {x: source.x, y: source.y};
                        return diagonal({source: o, target: o});
                    });

                // Stash the old positions for transition.
                root.eachBefore(d => {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });
            }

            const setLoading = () => {
                svgContainer.style.cursor = 'wait';
                gNode.attr('cursor', 'wait');
                gLink.attr('cursor', 'wait');
            };

            // Do the first update to the initial configuration of the tree — where a number of nodes
            // are open (arbitrarily selected as the root, plus nodes with 7 letters).

            return svg.node();
        }
        svgContainer.append(chart());
    </script>
{% endblock %}
